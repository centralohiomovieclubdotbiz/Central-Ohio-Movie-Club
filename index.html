<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Central Ohio Movie Club ‚Äì Showtimes</title>
<style>
  body { font-family: Arial, sans-serif; margin: 2rem; background: #fafafa; }
  h1 { text-align: center; }
  table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
  th, td { padding: 0.6rem; border: 1px solid #ccc; text-align: left; }
  th { cursor: pointer; background: #f2f2f2; }
  tr:nth-child(even) { background: #f9f9f9; }
  input, button { margin: 0.5rem 0; padding: 0.5rem; font-size: 1rem; }
</style>
</head>
<body>
  <h1>üé¨ Central Ohio Movie Club ‚Äì Showtimes</h1>

  <div>
    <input type="text" id="search" placeholder="Search by title, theater, or notes..." />
    <input type="date" id="dateFilter" />
    <button onclick="resetFilters()">Reset Filters</button>
  </div>

  <table id="showtimesTable">
    <thead>
      <tr>
        <th onclick="sortTable(0)">Theater ‚¨ç</th>
        <th onclick="sortTable(1)">Movie ‚¨ç</th>
        <th onclick="sortTable(2)">Day ‚¨ç</th>
        <th onclick="sortTable(3)">Date ‚¨ç</th>
        <th onclick="sortTable(4)">Time ‚¨ç</th>
        <th onclick="sortTable(5)">Notes ‚¨ç</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

<script>
const JSON_URL = "./cinemas.json";

async function loadData() {
  const res = await fetch(JSON_URL);
  const data = await res.json();
  populateTable(flattenData(data));
}

function flattenData(data) {
  const rows = [];
  for (const [theater, movies] of Object.entries(data)) {
    movies.forEach(movie => {
      movie.showtimes.forEach(st => {
        const [date, timeAndLabel] = st.split(" ");
        const labelMatch = /\((.*?)\)/.exec(st);
        const label = labelMatch ? labelMatch[1] : "";
        rows.push([
          theater,
          movie.title,
          new Date(date + " " + timeAndLabel).toLocaleDateString("en-US", { weekday: "long" }),
          new Date(date).toLocaleDateString(),
          timeAndLabel,
          label
        ]);
      });
    });
  }
  return rows;
}

function populateTable(rows) {
  const tbody = document.querySelector("#showtimesTable tbody");
  tbody.innerHTML = "";
  rows.forEach(row => {
    const tr = document.createElement("tr");
    row.forEach(cell => {
      const td = document.createElement("td");
      td.textContent = cell;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

function sortTable(colIndex) {
  const tbody = document.querySelector("#showtimesTable tbody");
  const rows = Array.from(tbody.querySelectorAll("tr"));
  const sorted = rows.sort((a, b) => {
    const A = a.children[colIndex].innerText.toLowerCase();
    const B = b.children[colIndex].innerText.toLowerCase();
    return A.localeCompare(B);
  });
  tbody.innerHTML = "";
  sorted.forEach(r => tbody.appendChild(r));
}

document.getElementById("search").addEventListener("input", () => {
  const filter = document.getElementById("search").value.toLowerCase();
  const rows = document.querySelectorAll("#showtimesTable tbody tr");
  rows.forEach(row => {
    row.style.display = row.innerText.toLowerCase().includes(filter) ? "" : "none";
  });
});

document.getElementById("dateFilter").addEventListener("change", () => {
  const selectedDate = new Date(document.getElementById("dateFilter").value);
  const rows = document.querySelectorAll("#showtimesTable tbody tr");
  rows.forEach(row => {
    const rowDate = new Date(row.children[3].innerText);
    row.style.display = rowDate >= selectedDate ? "" : "none";
  });
});

function resetFilters() {
  document.getElementById("search").value = "";
  document.getElementById("dateFilter").value = "";
  loadData();
}

loadData();
</script>
</body>
</html>
